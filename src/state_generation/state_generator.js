import { EMP } from "../constants/index";
import { BLK } from "../constants/index";
import { WHT } from "../constants/index";

// Create the initial Game State using marble coordinates generated by input.js
export function createInitialState(marbleCoords) {

    let initialState = {
        i: { 5: EMP, 6: EMP, 7: EMP, 8: EMP, 9: EMP },
        h: { 4: EMP, 5: EMP, 6: EMP, 7: EMP, 8: EMP, 9: EMP },
        g: { 3: EMP, 4: EMP, 5: EMP, 6: EMP, 7: EMP, 8: EMP, 9: EMP },
        f: { 2: EMP, 3: EMP, 4: EMP, 5: EMP, 6: EMP, 7: EMP, 8: EMP, 9: EMP },
        e: { 1: EMP, 2: EMP, 3: EMP, 4: EMP, 5: EMP, 6: EMP, 7: EMP, 8: EMP, 9: EMP },
        d: { 1: EMP, 2: EMP, 3: EMP, 4: EMP, 5: EMP, 6: EMP, 7: EMP, 8: EMP },
        c: { 1: EMP, 2: EMP, 3: EMP, 4: EMP, 5: EMP, 6: EMP, 7: EMP },
        b: { 1: EMP, 2: EMP, 3: EMP, 4: EMP, 5: EMP, 6: EMP },
        a: { 1: EMP, 2: EMP, 3: EMP, 4: EMP, 5: EMP }
      };

    // Go through each coordinate string, convert it, and place each marble on the board.
    for (let i = 0; i < marbleCoords.length; i++){
      // must set to lower case to work with our object
      let letter = marbleCoords[i][0].toLowerCase();
      // get num
      let num = marbleCoords[i][1];
      // color
      let color = marbleCoords[i][2];

      // set up initial state using coordinates.
      if (color === "w") {
        initialState[letter][num] = WHT;
      } else {
        initialState[letter][num] = BLK;
      }
    }

    // return the initial state
    return initialState;
}

// This function generates a set for duo and trio neighbouring marbles
export function generateMoves(startingColour, marbleCoords, initialState){
  let state = initialState;
  // get coordinates of only the marbles we will be moving
  let single_marbles = getCoordinatesUsingColour(startingColour, marbleCoords);
  // generate a list of duoing neighbour marbles
  let duo_marbles = getMarblePairs(single_marbles, state);
  // generate a list of trio neighbour marbles
  let trio_marbles = getMarbleTrios(duo_marbles, state);
  // Go through each list of marbles and check and generate moves for each one.
  let single_marble_moves = getSingleMarbleMoves(single_marbles, state);
  console.log(single_marble_moves);

  let double_marble_moves = getDoubleMarbleMoves(duo_marbles, state);
  console.log(double_marble_moves);

  // let triple_marble_moves = getTripleMarbleMoves();

}

// This function will go through each single marble and return all the possible moves as an array of strings
// coordinates is a list of coordinates of single marbles
// state is the state where we will be finding the legal moves
function getSingleMarbleMoves(coordinates, state){
  // moves will be placed in here
  let moves = [];
  // go through each marble and find the valid moves.
  for (let i = 0; i<coordinates.length; i++){
    let neighbours = getNeighbours(coordinates[i], state);
    for (let k = 0; k < neighbours.length; k++){
      if (neighbours[k].includes("emp")){
        // get the direction and create the correct move string
        let direction = getDirection(neighbours[k], coordinates[i].toLowerCase());
        let coord = coordinates[i].substr(0, 2).toUpperCase();
        let thisMove = `SINGLE ${coord} ${direction}`;
        moves.push(thisMove);
      }
    }
  }
  return moves;
}

function getDirection(pos1, pos2){
  let pos1K1 = pos1[0];
  let pos1K2 = parseInt(pos1[1]);
  let pos2K1 = pos2[0];
  let pos2K2 = parseInt(pos2[1]);
  const k1Diff = pos1K1.charCodeAt(0) - pos2K1.charCodeAt(0);
  const k2Diff = pos1K2 - pos2K2;
  if (k1Diff === -1 && k2Diff === 0) {
      return "NW";
  } else if (k1Diff === -1 && k2Diff === -1) {
      return "NE";
  } else if (k1Diff === 0 && k2Diff === -1) {
      return "E";
  } else if (k1Diff === 0 && k2Diff === 1) {
      return "W";
  } else if (k1Diff === 1 && k2Diff === 1) {
      return "SW";  
  } else if (k1Diff === 1 && k2Diff === 0) {
      return "SE";
  }
  return "Invalid";
}

// This function will go through each pair of marbles and return all the possible moves as an array of strings.
// coordinates is the coordinates of all marble pairs on the given state
// state is the state where we will be finding the legal moves
function getDoubleMarbleMoves(coordinates, state){
  let moves = [];
  console.log(coordinates);
  for (let i = 0; i < coordinates.length; i++) {
    let marble1 = coordinates[i].substr(0,3);
    let marble2 = coordinates[i].substr(3,3);
    let x1 = getNeighbours(marble1, state);
    let x2 = getNeighbours(marble2, state);
    let neighbours = mergeNoDuplicates(x1, x2);
    neighbours.splice(neighbours.indexOf(x1));
    neighbours.splice(neighbours.indexOf(x2));
    
    // all directions
    let directions = ["E", "W", "SW", "SE", "NW", "NE"];
    // inline directions
    let dir1 = getDirection(marble1, marble2);
    let dir2 = getDirection(marble2, marble1);

    // Check the inline directions for inline moves.
    let inline_moves = getInlineMovesForPairs(dir1, dir2, marble1, marble2, state);
    console.log(inline_moves);
    
    // for (let k = 0; k < neighbours.length;k++){
      
    // }

  }
  return moves;
}

function getNeighbourInDirection(direction, coordinate, state){
  if(direction == "E"){
    let num = parseInt(coordinate[1])+1;
    let letter = coordinate[0];
    return state[letter][num];
  }else if(direction == "W") {
    let num = parseInt(coordinate[1])-1;
    let letter = coordinate[0];
    return state[letter][num];
  }else if(direction == "SW"){
    let num = parseInt(coordinate[1])-1;
    let letter = coordinate[0];
    letter = String.fromCharCode(letter.charCodeAt(0) - 1);
    return state[letter][num];
  }else if(direction == "SE"){
    let num = parseInt(coordinate[1]);
    let letter = coordinate[0];
    letter = String.fromCharCode(letter.charCodeAt(0) - 1);
    return state[letter][num];
  }else if(direction == "NW"){
    let num = parseInt(coordinate[1]);
    let letter = coordinate[0];
    letter = String.fromCharCode(letter.charCodeAt(0) + 1);
    return state[letter][num];
  }else if(direction == "NE"){
    let num = parseInt(coordinate[1])+1;
    let letter = coordinate[0];
    letter = String.fromCharCode(letter.charCodeAt(0) + 1);
    return state[letter][num];
  }
return "invalid direction";
}

function getCoordinateByDirection(coordinate, direction, state){
  if(direction == "E"){
    let num = parseInt(coordinate[1])+1;
    let letter = coordinate[0];
    let colour = getColourFromCoordinate(letter, num, state);
    return `${letter}${num}${colour}`;
  }else if(direction == "W") {
    let num = parseInt(coordinate[1])-1;
    let letter = coordinate[0];
    let colour = getColourFromCoordinate(letter, num, state);
    return `${letter}${num}${colour}`;
  }else if(direction == "SW"){
    let num = parseInt(coordinate[1])-1;
    let letter = coordinate[0];
    letter = String.fromCharCode(letter.charCodeAt(0) - 1);
    let colour = getColourFromCoordinate(letter, num, state);
    return `${letter}${num}${colour}`;
  }else if(direction == "SE"){
    let num = parseInt(coordinate[1]);
    let letter = coordinate[0];
    letter = String.fromCharCode(letter.charCodeAt(0) - 1);
    let colour = getColourFromCoordinate(letter, num, state);
    return `${letter}${num}${colour}`;
  }else if(direction == "NW"){
    let num = parseInt(coordinate[1]);
    let letter = coordinate[0];
    letter = String.fromCharCode(letter.charCodeAt(0) + 1);
    let colour = getColourFromCoordinate(letter, num, state);
    return `${letter}${num}${colour}`;
  }else if(direction == "NE"){
    let num = parseInt(coordinate[1])+1;
    let letter = coordinate[0];
    letter = String.fromCharCode(letter.charCodeAt(0) + 1);
    let colour = getColourFromCoordinate(letter, num, state);
    return `${letter}${num}${colour}`;
  }
}

function getInlineMovesForPairs(dir1, dir2, marble1, marble2, state){
  let moves = [];
  let val1 = getNeighbourInDirection(dir1, marble1, state);
  let val2 = getNeighbourInDirection(dir1, marble2, state);
  let val3 = getNeighbourInDirection(dir2, marble1, state);
  let val4 = getNeighbourInDirection(dir2, marble2, state);
  let letter1 = marble1[0]
  let num1 = marble1[1]
  let letter2 = marble2[0]
  let num2 = marble2[1]
  if (val1 != state[letter1][num1]){
    if (val1 == 0){
      let move = `INLINE ${marble1+marble2} ${dir1}`;
      moves.push(move);
    } else {
      let opponent_marble_coordinate = getCoordinateByDirection(marble1, dir1, state);
      let move = checkSumitoForPair(opponent_marble_coordinate, dir1, state);
      if (!move){
        moves.push(move);
      }
    }
  } 
  if (val3 != state[letter1][num1]){
    if (val3 == 0){
      let move = `INLINE ${marble1+marble2} ${dir2}`;
      moves.push(move);
    } else {
      let opponent_marble_coordinate = getCoordinateByDirection(marble1, dir1, state);
      let move = checkSumitoForPair(opponent_marble_coordinate, dir1, state);
      if (!move){
        moves.push(move);
      }
  }
}
  if (val2 != state[letter2][num2]){
    if (val2 == 0){
      let move = `INLINE ${marble1+marble2} ${dir1}`;
      moves.push(move);
    }else {
      let opponent_marble_coordinate = getCoordinateByDirection(marble1, dir1, state);
      let move = checkSumitoForPair(opponent_marble_coordinate, dir1, state);
      if (!move){
        moves.push(move);
      }
  }
}
  if (val4 != state[letter2][num2]){
    if (val4 == 0){
      let move = `INLINE ${marble1+marble2} ${dir2}`;
      moves.push(move);
    }else {
      let opponent_marble_coordinate = getCoordinateByDirection(marble1, dir1, state);
      let move = checkSumitoForPair(opponent_marble_coordinate, dir1, state);
      if (!move){
        moves.push(move);
      }
  }
  }
return moves;
}

function checkSumitoForPair(){

}

function mergeNoDuplicates(...arrays) { 
  let mergedArray = []; 

  arrays.forEach(array => { 
      mergedArray = [...mergedArray, ...array] 
  }); 

  return [...new Set([...mergedArray])]; 
} 

// This function will go through each triple group of marbles and return all the possible moves as an array of strings.
// coordinates is the coordinates for all 3 marble groupings
// state is the state where we will be finding the legal moves
function getTripleMarbleMoves(coordinates, state){
  let moves = [];
  return moves;
}


// This function returns a list of duo marble neighbours
function getMarblePairs(coordinates, state) {
  let duo_marbles = [];
  for (let i = 0; i < coordinates.length; i++){
    let thisMarble = coordinates[i];
    let neighbours = getNeighbours(thisMarble, state);
    for (let k = 0; k < neighbours.length; k++){
      if (thisMarble[2] == neighbours[k][2]){
        duo_marbles.push(thisMarble.toLowerCase() + neighbours[k]);
      }
    }
  }
  return duo_marbles;
}

// This function returns a list of trio marble neighbours
function getMarbleTrios(duo_coordinates, state){
  let trio_marbles = [];
  for (let i = 0; i < duo_coordinates.length; i++){
    let marble_letter = duo_coordinates[i][3].charCodeAt(0) - duo_coordinates[i][0].charCodeAt(0);
    let marble_num = duo_coordinates[i][4] - duo_coordinates[i][1];
    let x = duo_coordinates[i][3].charCodeAt(0)+marble_letter;
    let y = parseInt(duo_coordinates[i][4])+marble_num;
    if (String.fromCharCode(x).search(/[^a-i\s]/) != -1 || y > 9 || y < 1){
      continue;
    }
    let marble_colour = getColourFromCoordinate(
      String.fromCharCode(x),
      y,
      state);
    if (marble_colour == duo_coordinates[i][2]){
      trio_marbles.push(duo_coordinates[i]+String.fromCharCode(x)+y+marble_colour);
    }
  }
  return trio_marbles;
}

// This function returns a list of neighbours
function getNeighbours(coord, state){
  let letter = coord[0].toLowerCase().charCodeAt(0);
  let num = parseInt(coord[1]);
  let neighbours = [];
  try {
    let tempLetter = String.fromCharCode(letter-1);
    let tempNum = num - 1;
    if (state[tempLetter][tempNum] == undefined) {
      throw Error();
    };
    let colour = getColourFromCoordinate(tempLetter, tempNum, state);
    neighbours.push(tempLetter+tempNum+colour);
  } catch (err) {
    console.log();
  }
  try {
    let tempLetter = String.fromCharCode(letter);
    let tempNum = num-1;
    if (state[tempLetter][tempNum] == undefined) {
      throw Error();
    };
    let colour = getColourFromCoordinate(tempLetter, tempNum, state);
    neighbours.push(tempLetter+tempNum+colour);
  } catch(err) {
    console.log();
  }
  try {
    let tempLetter = String.fromCharCode(letter);
    let tempNum = num+1;
    if (state[tempLetter][tempNum] == undefined) {
      throw Error();
    };
    let colour = getColourFromCoordinate(tempLetter, tempNum, state);
    neighbours.push(tempLetter+tempNum+colour);
  } catch(err) {
    console.log();
  }
  try {
    let tempLetter = String.fromCharCode(letter+1);
    let tempNum = num;
    if (state[tempLetter][tempNum] == undefined) {
      throw Error();
    };
    let colour = getColourFromCoordinate(tempLetter, tempNum, state);
    neighbours.push(tempLetter+tempNum+colour);
  } catch(err) {
    console.log();
  }
  try {
    let tempLetter = String.fromCharCode(letter+1);
    let tempNum = num+1;
    if (state[tempLetter][tempNum] == undefined) {
      throw Error();
    };
    let colour = getColourFromCoordinate(tempLetter, tempNum, state);
    neighbours.push(tempLetter+tempNum+colour);
  } catch(err) {
    console.log();
  }
  try {
    let tempLetter = String.fromCharCode(letter-1);
    let tempNum = num;
    if (state[tempLetter][tempNum] == undefined) {
      throw Error();
    };
    let colour = getColourFromCoordinate(tempLetter, tempNum, state);
    neighbours.push(tempLetter+tempNum+colour);
  } catch(err) {
    console.log();
  }
  return neighbours;
}

function getColourFromCoordinate(letter, num, state) {
  if (state[letter][num] == 2) {
    return "w";
  } else if (state[letter][num] == 1) {
    return "b";
  } else {
    return "emp";
  };
}

// This function returns a list of coordinates for only the marbles that match the startingColour
function getCoordinatesUsingColour(startingColour, marbleCoords){
  let coordinates = [];
  // If the starting colour is white then get the coordinates for the white marbles
  if (startingColour.includes("w")){
    for (let i = 0; i < marbleCoords.length; i++){
      if (marbleCoords[i].includes("w")){coordinates.push(marbleCoords[i].toLowerCase())};
    }
  // If the starting colour is black then get the coordinates for the black marbles
  } else {
    for (let i = 0; i < marbleCoords.length; i++){
      if (marbleCoords[i].includes("b")){coordinates.push(marbleCoords[i].toLowerCase())};
    }
  }
  return coordinates;
}
