import {EMP, BLK, WHT} from "../constants/index";
import {DIRECTION} from "../constants";

// Create the initial Game State using marble coordinates generated by input.js
export const createInitialState = (marbleCoords) => {

  const initialState = {
    i: {5: EMP, 6: EMP, 7: EMP, 8: EMP, 9: EMP},
    h: {4: EMP, 5: EMP, 6: EMP, 7: EMP, 8: EMP, 9: EMP},
    g: {3: EMP, 4: EMP, 5: EMP, 6: EMP, 7: EMP, 8: EMP, 9: EMP},
    f: {2: EMP, 3: EMP, 4: EMP, 5: EMP, 6: EMP, 7: EMP, 8: EMP, 9: EMP},
    e: {1: EMP, 2: EMP, 3: EMP, 4: EMP, 5: EMP, 6: EMP, 7: EMP, 8: EMP, 9: EMP},
    d: {1: EMP, 2: EMP, 3: EMP, 4: EMP, 5: EMP, 6: EMP, 7: EMP, 8: EMP},
    c: {1: EMP, 2: EMP, 3: EMP, 4: EMP, 5: EMP, 6: EMP, 7: EMP},
    b: {1: EMP, 2: EMP, 3: EMP, 4: EMP, 5: EMP, 6: EMP},
    a: {1: EMP, 2: EMP, 3: EMP, 4: EMP, 5: EMP}
  };

  // Go through each coordinate string, convert it, and place each marble on the board.
  for (let i = 0; i < marbleCoords.length; i++) {
    // must set to lower case to work with our object
    const letter = marbleCoords[i][0].toLowerCase();
    // get num
    const num = marbleCoords[i][1];
    // color
    const color = marbleCoords[i][2];

    // set up initial state using coordinates.
    if (color === "w") {
      initialState[letter][num] = WHT;
    } else {
      initialState[letter][num] = BLK;
    }
  }

  // return the initial state
  return initialState;
}

const getColourFromCoordinate = (letter, num, state) => {
  if (state[letter][num] === 2) {
    return "w";
  } else if (state[letter][num] === 1) {
    return "b";
  } else {
    return "emp";
  }
}

// This function returns a list of coordinates for only the marbles that match the startingColour
const getCoordinatesUsingColour = (startingColour, marbleCoords) => {
  const coordinates = [];
  // If the starting colour is white then get the coordinates for the white marbles
  if (startingColour.includes("w")) {
    for (let i = 0; i < marbleCoords.length; i++) {
      if (marbleCoords[i].includes("w")) {
        coordinates.push(marbleCoords[i].toLowerCase())
      }
    }
    // If the starting colour is black then get the coordinates for the black marbles
  } else {
    for (let i = 0; i < marbleCoords.length; i++) {
      if (marbleCoords[i].includes("b")) {
        coordinates.push(marbleCoords[i].toLowerCase())
      }
    }
  }
  return coordinates;
}

// This function generates a set for duo and trio neighbouring marbles
export const generateMoves = (startingColour, marbleCoords, initialState) => {
  // get coordinates of only the marbles we will be moving
  const single_marbles = getCoordinatesUsingColour(startingColour, marbleCoords);
  // generate a list of duoing neighbour marbles
  const duo_marbles = getMarblePairs(single_marbles, initialState);
  // generate a list of trio neighbour marbles
  const trio_marbles = getMarbleTrios(duo_marbles, initialState);
  // Go through each list of marbles and check and generate moves for each one.
  const single_marble_moves = getSingleMarbleMoves(single_marbles, initialState);
  console.log(single_marble_moves)

  // let double_marble_moves = getDoubleMarbleMoves();

  const triple_marble_moves = getTripleMarbleMoves(trio_marbles, initialState);

}

// This function will go through each single marble and return all the possible moves as an array of strings
// coordinates is a list of coordinates of single marbles
const getDirection = (pos1, pos2) => {
  const pos1row = pos1[0];
  const pos1col = parseInt(pos1[1]);
  const pos2row = pos2[0];
  const pos2col = parseInt(pos2[1]);

  const rowDiff = pos1row.charCodeAt(0) - pos2row.charCodeAt(0);
  const colDiff = pos1col - pos2col;
  if (rowDiff === -1 && colDiff === 0) {
    return DIRECTION.NW;
  } else if (rowDiff === -1 && colDiff === -1) {
    return DIRECTION.NE;
  } else if (rowDiff === 0 && colDiff === -1) {
    return DIRECTION.E;
  } else if (rowDiff === 0 && colDiff === 1) {
    return DIRECTION.W;
  } else if (rowDiff === 1 && colDiff === 1) {
    return DIRECTION.SW;
  } else if (rowDiff === 1 && colDiff === 0) {
    return DIRECTION.SE;
  }
}


// This function returns a list of duo marble neighbours
const getMarblePairs = (coordinates, state) => {
  const duo_marbles = [];
  for (let i = 0; i < coordinates.length; i++) {
    const thisMarble = coordinates[i];
    const neighbours = getNeighbours(thisMarble, state);
    for (let k = 0; k < neighbours.length; k++) {
      if (thisMarble[2] === neighbours[k][2]) {
        duo_marbles.push(thisMarble.toLowerCase() + neighbours[k]);
      }
    }
  }
  return duo_marbles;
}

// This function returns a list of trio marble neighbours
const getMarbleTrios = (duo_coordinates, state) => {
  const trio_marbles = [];
  for (let i = 0; i < duo_coordinates.length; i++) {
    const marble_letter = duo_coordinates[i][3].charCodeAt(0) - duo_coordinates[i][0].charCodeAt(0);
    const marble_num = duo_coordinates[i][4] - duo_coordinates[i][1];
    const x = duo_coordinates[i][3].charCodeAt(0) + marble_letter;
    const y = parseInt(duo_coordinates[i][4]) + marble_num;
    if (String.fromCharCode(x).search(/[^a-i\s]/) !== -1 || y > 9 || y < 1) {
      continue;
    }
    const marble_colour = getColourFromCoordinate(
      String.fromCharCode(x),
      y,
      state);
    if (marble_colour === duo_coordinates[i][2]) {
      trio_marbles.push(duo_coordinates[i] + String.fromCharCode(x) + y + marble_colour);
    }
  }
  return trio_marbles;
}

// This function returns a list of neighbours
const getNeighbours = (coord, state) => {
  const letterCode = coord[0].toLowerCase().charCodeAt(0);
  const num = parseInt(coord[1]);
  const neighbours = [];

  const spacesAround = [
    {row: String.fromCharCode(letterCode - 1), col: num - 1},
    {row: String.fromCharCode(letterCode - 1), col: num},
    {row: String.fromCharCode(letterCode), col: num - 1},
    {row: String.fromCharCode(letterCode), col: num + 1},
    {row: String.fromCharCode(letterCode + 1), col: num},
    {row: String.fromCharCode(letterCode + 1), col: num + 1},
  ]

  spacesAround.forEach(space => {
    try {
      const neighbour = state[space.row][space.col];
      if (neighbour !== undefined) {
        const colour = getColourFromCoordinate(space.row, space.col, state);
        neighbours.push(space.row + space.col + colour);
      }
    } catch (ignored) {}
  });

  return neighbours;
}

// state is the state where we will be finding the legal moves
const getSingleMarbleMoves = (coordinates, state) => {
  // moves will be placed in here
  const moves = [];
  // go through each marble and find the valid moves.
  for (let i = 0; i < coordinates.length; i++) {
    const neighbours = getNeighbours(coordinates[i], state);
    for (let k = 0; k < neighbours.length; k++) {
      if (neighbours[k].includes("emp")) {
        // get the direction and create the correct move string
        const direction = getDirection(neighbours[k], coordinates[i].toLowerCase());
        const coord = coordinates[i].substr(0, 2).toUpperCase();
        const thisMove = `SINGLE ${coord} ${direction}`;
        moves.push(thisMove);
      }
    }
  }
  return moves;
}

// This function will go through each pair of marbles and return all the possible moves as an array of strings.
// coordinates is the coordinates of all marble pairs on the given state
// state is the state where we will be finding the legal moves
const getDoubleMarbleMoves = (coordinates, state) => {

  return '';
}

// This function will go through each triple group of marbles and return all the possible moves as an array of strings.
// coordinates is the coordinates for all 3 marble groupings
// state is the state where we will be finding the legal moves
const getTripleMarbleMoves = (coordinates, state) => {
  const moves = [];
  coordinates.forEach(set => {
    console.log(set)
    const marbles = [];

    for (let i = 0; i < 3; i++) {
      const marble = set.substr(i * 3, 3);
      marbles.push({row: marble.charAt(0), col: parseInt(marble.charAt(1))});
    }

    const groups = setMultiMoveGroups(marbles[0].row + marbles[0].col,
      marbles[1].row + marbles[0].col);
    const inline = groups[0];
    const sidestep = groups[1];

    //TODO finish this
  })
}

const setMultiMoveGroups = (marble1, marble2) => {
  let inline;
  let sidestep;

  const rowDir = getDirection(marble1, marble2);
  switch (rowDir) {
    case DIRECTION.NW:
    case DIRECTION.SE:
      inline = [DIRECTION.NW, DIRECTION.SE];
      sidestep = [DIRECTION.E, DIRECTION.W, DIRECTION.NE, DIRECTION.SW];
      break;
    case DIRECTION.E:
    case DIRECTION.W:
      inline = [DIRECTION.E, DIRECTION.W];
      sidestep = [DIRECTION.NW, DIRECTION.SE, DIRECTION.NE, DIRECTION.SW];
      break;
    case DIRECTION.NE:
    case DIRECTION.SW:
      inline = [DIRECTION.SW, DIRECTION.NE];
      sidestep = [DIRECTION.E, DIRECTION.W, DIRECTION.NW, DIRECTION.SE];
      break;
  }

  return [inline, sidestep];
}